#include "../dep/laynii_lib.h"
#include <limits>
#include <sstream>


int show_help(void) {
    printf(
    "LN2_INTPRO: Intensity projections. Useful for e.g. highlighting vessels.\n"
    "\n"
    "Usage:\n"
    "     LN2_INTPRO -input file.nii -min -range 3 \n"
    "\n"
    "Options:\n"
    "    -help      : Show this help\n"
    "    -input     : Nifti (.nii) for intensity projections. \n"
    "    -axis      : Axis of the projection. x=1, y=2, z=4. Default is '3'.\n"
    "                 Projections over each axis can be generated by using '0'.\n"
    "    -range     : Number of voxels in either side of the projection plane.\n"
    "                 Default is '5'. E.g. value of '5' indicates the projection\n" 
    "                 will be performed over 11 (5+1+5) voxels in total.\n"
    "    -output    : (Optional) Output filename, including .nii or\n"
    "                 .nii.gz, and path if needed. Overwrites existing files.\n"
    "\n");
    return 0;
}

int main(int argc, char * argv[]) {
    char *fin = NULL, *fout = NULL;
    int64_t ac, axis = 3, range = 5;

    // Process user options
    if (argc < 2) return show_help();
    for (ac = 1; ac < argc; ac++) {
        if (!strncmp(argv[ac], "-h", 2)) {
            return show_help();
        } else if (!strcmp(argv[ac], "-input")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -input\n");
                return 1;
            }
            fin = argv[ac];
            fout = argv[ac];
        } else if (!strcmp(argv[ac], "-axis")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -axis\n");
            } else {
                axis = atof(argv[ac]);
            }
        } else if (!strcmp(argv[ac], "-range")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -range\n");
            } else {
                range = atof(argv[ac]);
            }
        } else if (!strcmp(argv[ac], "-output")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -output\n");
                return 1;
            }
            fout = argv[ac];
        }
    }

    if (!fin) {
        fprintf(stderr, "** missing option '-input'\n");
        return 1;
    }
    // Read input dataset
    nifti_image * nii1 = nifti_image_read(fin, 1);
    if (!nii1) {
        fprintf(stderr, "** failed to read NIfTI image from '%s'\n", fin);
        return 2;
    }

    // Read input dataset, including data
    if ( axis < 0 || axis > 3) {
        fprintf(stderr, "Incorrect axis value. Please choose between 0, 1, 2, 3.\n");
        return 2;
    }

    log_welcome("LN2_INTPRO");
    log_nifti_descriptives(nii1);

    // Get dimensions of input
    const int64_t size_x = static_cast<int64_t>(nii1->nx);
    const int64_t size_y = static_cast<int64_t>(nii1->ny);
    const int64_t size_z = static_cast<int64_t>(nii1->nz);
    const int64_t size_time =  static_cast<int64_t>(nii1->nt);
    const int64_t nr_voxels = size_z * size_y * size_x;

    // ========================================================================
    // Fix data type issues
    nifti_image* nii_input = copy_nifti_as_float32(nii1);
    float* nii_input_data = static_cast<float*>(nii_input->data);

    nifti_image* nii_output = copy_nifti_as_float32(nii1);
    float* nii_output_data = static_cast<float*>(nii_output->data);

    // ========================================================================
    std::ostringstream tag_range;
    tag_range << range;

    // ------------------------------------------------------------------------
    if ( axis == 1 || axis == 0 ) {
        cout << "  Minimum intensity projection over x..." << endl;

        int64_t ix, iy, iz, it, j;
        for (int64_t t = 0; t != size_time; ++t) {
            cout << "\r    Volume: " << t+1 << "/" << size_time << flush;
            for (int64_t i = 0; i != nr_voxels; ++i) {
                tie(ix, iy, iz, it) = ind2sub_4D_64(i+nr_voxels*t, size_x, size_y, size_z);
                float temp = std::numeric_limits<float>::max();

                for (int64_t x = ix-range; x != ix+range; ++x ) {
                    if (x > 0 && x < size_x) {
                        j = sub2ind_4D_64(x, iy, iz, it, size_x, size_y, size_z);
                        if ( *(nii_input_data + j) < temp) {
                            temp = *(nii_input_data + j);
                        }
                    }
                *(nii_output_data + i+nr_voxels*t) = temp;
                }
            }
        }

        cout << endl;
        cout << "  Saving output..." << endl;
        save_output_nifti(fout, "minip-x_range-"+tag_range.str(), nii_output, true);        
    }

    // ------------------------------------------------------------------------
    if ( axis == 2 || axis == 0 ) {
        cout << "  Minimum intensity projection over y..." << endl;

        int64_t ix, iy, iz, it, j;
        for (int64_t t = 0; t != size_time; ++t) {
            cout << "\r    Volume: " << t+1 << "/" << size_time << flush;
            for (int64_t i = 0; i != nr_voxels; ++i) {
                tie(ix, iy, iz, it) = ind2sub_4D_64(i+nr_voxels*t, size_x, size_y, size_z);
                float temp = std::numeric_limits<float>::max();

                for (int64_t y = iy-range; y != iy+range; ++y ) {
                    if (y > 0 && y < size_y) {
                        j = sub2ind_4D_64(ix, y, iz, it, size_x, size_y, size_z);
                        if ( *(nii_input_data + j) < temp) {
                            temp = *(nii_input_data + j);
                        }
                    }
                *(nii_output_data + i+nr_voxels*t) = temp;
                }
            }
        }

        cout << endl;
        cout << "  Saving output..." << endl;
        save_output_nifti(fout, "minip-y_range-"+tag_range.str(), nii_output, true);        
    }

    // ------------------------------------------------------------------------
    if ( axis == 3 || axis == 0 ) {
        cout << "  Minimum intensity projection over z..." << endl;

        int64_t ix, iy, iz, it, j;
        for (int64_t t = 0; t != size_time; ++t) {
            cout << "\r    Volume: " << t+1 << "/" << size_time << flush;
            for (int64_t i = 0; i != nr_voxels; ++i) {
                tie(ix, iy, iz, it) = ind2sub_4D_64(i+nr_voxels*t, size_x, size_y, size_z);
                float temp = std::numeric_limits<float>::max();

                for (int64_t z = iz-range; z != iz+range; ++z ) {
                    if (z > 0 && z < size_z) {
                        j = sub2ind_4D_64(ix, iy, z, it, size_x, size_y, size_z);
                        if ( *(nii_input_data + j) < temp) {
                            temp = *(nii_input_data + j);
                        }
                    }
                *(nii_output_data + i+nr_voxels*t) = temp;
                }
            }
        }

        cout << endl;
        cout << "  Saving output..." << endl;

        save_output_nifti(fout, "minip-z_range-"+tag_range.str(), nii_output, true);        
    }

    cout << "\n  Finished." << endl;
    return 0;
}
