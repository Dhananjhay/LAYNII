#include "../dep/laynii_lib.h"
#include <sstream>

int show_help(void) {
    printf(
    "LN2_MULTILATERATE: Injects a coordinate system upon a region of the rim file.\n"
    "                   These coordinates can be used to flatten chunks of the brain.\n"
    "                   Or, to generate bins/cells (subsets of voxels).\n"
    "Usage:\n"
    "    LN2_MULTILATERATE -rim rim.nii -control_points rim_midgm_control_point_0.nii -radius 10\n"
    "    LN2_MULTILATERATE -rim rim.nii -control_points rim_midgm_control_points.nii -radius 10\n"
    "\n"
    "Options:\n"
    "    -help           : Show this help.\n"
    "    -rim            : Segmentation input. Use 3 to code gray matter voxels\n"
    "                      This program only injects coordinates to the voxels\n"
    "                      labeled with 3.\n"
    "    -control_points : A middle gray matter nifti file generated by LN2_LAYERS\n"
    "                      which is additionally modified (e.g. using ITKSNAP or FSLEYES)\n"
    "                      to follow one of the two cases:\n"
    "                      CASE I: One midgm voxel labeled with value '2' indicates\n"
    "                      the centroid/origin of the region of interest.\n"
    "                      CASE II: Four additional voxels with values '3, 4, 5, 6'.\n"
    "                      The voxels labeled with 3 & 4 approximately determine\n"
    "                      the first axis and the voxels labeled with 5 & 6 approximately\n"
    "                      determine the second axis.\n"
    "                      The points refer to the extrema of the UV coordinates. \n"
    "                      Specifically: 3 = Min U, 4 = Max U, 5 = Min V, 6 = Max V. \n"
    "    -radius         : Distance from 'control point 0' (origin of UV coordinates)\n"
    "                      the other control points.\n"
    "    -nomask         : (Conditional) Outputs are not masked to fall within radius.\n"
    "                      Can only be used together with 'control_points' CASE I.\n"
    "    -incl_borders   : (Conditional) Include borders as if they are labeled with 3.\n"
    "    -norms          : (Optional) Save L2 and Linf norm of the UV coordinates.\n"
    "    -angles         : (Optional) Save angles in radians and 4 quadrants.\n"
    "    -debug          : (Optional) Save extra intermediate outputs.\n"
    "    -output         : (Optional) Output basename for all outputs.\n"
    "\n"
    "Notes:\n"
    "    - Outputs of this program is often used with LN2_PATCH_FLATTEN.\n"
    "    - You can find further explanation of this algorithm at:\n"
    "      <https://thingsonthings.org/ln2_multilaterate>\n"
    "\n"
    "Citation:\n"
    "    - Gulban, O. F., Bollmann, S., Huber, R., Wagstyl, K., Goebel, R., Poser,\n"
    "      B. A., Kay, K., Ivanov, D. (2022). Mesoscopic in vivo human T2* dataset\n"
    "      acquired using quantitative MRI at 7 Tesla. Neuroimage.\n"
    "      <https://doi.org/10.1016/j.neuroimage.2022.119733>\n"
    "\n");
    return 0;
}

int main(int argc, char*  argv[]) {

    nifti_image *nii1 = NULL, *nii2 = NULL;
    char *fin1 = NULL, *fout = NULL, *fin2=NULL;
    float thr_radius = 10;
    int ac;
    bool mode_debug = false, mode_mask=true, mode_incl_borders = false;
    bool mode_norms = false, mode_angles=false;

    // Process user options
    if (argc < 2) return show_help();
    for (ac = 1; ac < argc; ac++) {
        if (!strncmp(argv[ac], "-h", 2)) {
            return show_help();
        } else if (!strcmp(argv[ac], "-rim")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -rim\n");
                return 1;
            }
            fin1 = argv[ac];
            fout = argv[ac];
        } else if (!strcmp(argv[ac], "-control_points")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -control_points\n");
                return 1;
            }
            fin2 = argv[ac];
        } else if (!strcmp(argv[ac], "-radius")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -radius\n");
                return 1;
            }
            thr_radius = atof(argv[ac]);
        } else if (!strcmp(argv[ac], "-nomask")) {
            mode_mask = false;
        } else if (!strcmp(argv[ac], "-incl_borders")) {
            mode_incl_borders = true;
        } else if (!strcmp(argv[ac], "-norms")) {
            mode_norms = true;
        } else if (!strcmp(argv[ac], "-angles")) {
            mode_angles = true;
        } else if (!strcmp(argv[ac], "-output")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -output\n");
                return 1;
            }
            fout = argv[ac];
        } else if (!strcmp(argv[ac], "-debug")) {
            mode_debug = true;
        } else {
            fprintf(stderr, "** invalid option, '%s'\n", argv[ac]);
            return 1;
        }
    }

    if (!fin1) {
        fprintf(stderr, "** missing option '-rim'\n");
        return 1;
    }
    if (!fin2) {
        fprintf(stderr, "** missing option '-control_points'\n");
        return 1;
    }

    // Read input dataset, including data
    nii1 = nifti_image_read(fin1, 1);
    if (!nii1) {
        fprintf(stderr, "** failed to read NIfTI from '%s'\n", fin1);
        return 2;
    }
    nii2 = nifti_image_read(fin2, 1);
    if (!nii2) {
        fprintf(stderr, "** failed to read NIfTI from '%s'\n", fin2);
        return 2;
    }

    log_welcome("LN2_MULTILATERATE");
    log_nifti_descriptives(nii1);
    log_nifti_descriptives(nii2);

    // Get dimensions of input
    const uint32_t size_x = nii1->nx;
    const uint32_t size_y = nii1->ny;
    const uint32_t size_z = nii1->nz;

    const uint32_t end_x = size_x - 1;
    const uint32_t end_y = size_y - 1;
    const uint32_t end_z = size_z - 1;

    const uint32_t nr_voxels = size_z * size_y * size_x;

    const float dX = nii1->pixdim[1];
    const float dY = nii1->pixdim[2];
    const float dZ = nii1->pixdim[3];

    // Short diagonals
    const float dia_xy = sqrt(dX * dX + dY * dY);
    const float dia_xz = sqrt(dX * dX + dZ * dZ);
    const float dia_yz = sqrt(dY * dY + dZ * dZ);
    // Long diagonals
    const float dia_xyz = sqrt(dX * dX + dY * dY + dZ * dZ);

    // ========================================================================
    // Fix input datatype issues
    nifti_image* nii_rim = copy_nifti_as_int32(nii1);
    int32_t* nii_rim_data = static_cast<int32_t*>(nii_rim->data);
    free(nii1);
    // ------------------------------------------------------------------------
    // Include borders adjustment to rim labels
    if (mode_incl_borders) {
        for (uint32_t i = 0; i != nr_voxels; ++i) {
            if (*(nii_rim_data + i) != 0){
                *(nii_rim_data + i) = 3;
            }
        }
    }
    // ------------------------------------------------------------------------
    // Control points file (modified middle gray matter)
    nifti_image* control_points = copy_nifti_as_int32(nii2);
    int32_t* control_points_data = static_cast<int32_t*>(control_points->data);
    free(nii2);

    // Prepare flood fill related nifti images
    nifti_image* flood_step = copy_nifti_as_int32(nii_rim);
    int32_t* flood_step_data = static_cast<int32_t*>(flood_step->data);
    nifti_image* flood_dist = copy_nifti_as_float32(nii_rim);
    float* flood_dist_data = static_cast<float*>(flood_dist->data);

    nifti_image* perimeter = copy_nifti_as_int32(nii_rim);
    int32_t* perimeter_data = static_cast<int32_t*>(perimeter->data);

    // Set to zero
    for (uint32_t i = 0; i != nr_voxels; ++i) {
        *(flood_step_data + i) = 0;
        *(flood_dist_data + i) = 0;
        *(perimeter_data + i) = 0;
    }

    // ------------------------------------------------------------------------
    // Create a 4D nifti image for point distances
    nifti_image* point_dist = nifti_copy_nim_info(flood_dist);
    point_dist->dim[0] = 4;  // For proper 4D nifti
    point_dist->dim[1] = size_x;
    point_dist->dim[2] = size_y;
    point_dist->dim[3] = size_z;
    point_dist->dim[4] = 4;
    nifti_update_dims_from_array(point_dist);
    point_dist->nvox = nr_voxels * 4;
    point_dist->nbyper = sizeof(float);
    point_dist->data = calloc(point_dist->nvox, point_dist->nbyper);
    float* point_dist_data = static_cast<float*>(point_dist->data);

    // Create a 4D nifti image for UV coordinates
    nifti_image* point_coords = nifti_copy_nim_info(flood_dist);
    point_coords->dim[0] = 4;  // For proper 4D nifti
    point_coords->dim[1] = size_x;
    point_coords->dim[2] = size_y;
    point_coords->dim[3] = size_z;
    point_coords->dim[4] = 2;
    nifti_update_dims_from_array(point_coords);
    point_coords->nvox = nr_voxels * 2;
    point_coords->nbyper = sizeof(float);
    point_coords->data = calloc(point_coords->nvox, point_coords->nbyper);
    float* point_coords_data = static_cast<float*>(point_coords->data);

    // Rolling pin axes
    nifti_image* pin_axes = copy_nifti_as_int32(point_coords);
    int32_t* pin_axes_data = static_cast<int32_t*>(pin_axes->data);

    // Pin coordinates
    nifti_image* pin_coords = copy_nifti_as_float32(point_coords);
    float* pin_coords_data = static_cast<float*>(pin_coords->data);

    // ------------------------------------------------------------------------
    // Final voronoi volume to output midgm distances for whole rim
    nifti_image* voronoi = copy_nifti_as_float32(flood_dist);
    float* voronoi_data = static_cast<float*>(voronoi->data);
    nifti_image* smooth = copy_nifti_as_float32(flood_dist);
    float* smooth_data = static_cast<float*>(smooth->data);

    // ------------------------------------------------------------------------
    // NOTE(Faruk): This section is written to constrain the big iterative
    // flooding distance loop to the subset of voxels. Required for substantial
    // speed boost.
    // ------------------------------------------------------------------------
    // Find the subset voxels that will be used many times
    uint32_t nr_voi = 0;  // Voxels of interest
    for (uint32_t i = 0; i != nr_voxels; ++i) {
        if (*(control_points_data + i) > 0){
            nr_voi += 1;
        }
    }
    cout << "  Nr. midgm voxels = " << nr_voi << endl;

    // Allocate memory to only the voxel of interest
    int32_t* voi_id;
    voi_id = (int32_t*) malloc(nr_voi*sizeof(int32_t));
    // Fill in indices to be able to remap from subset to full set of voxels
    uint32_t ii = 0;
    for (uint32_t i = 0; i != nr_voxels; ++i) {
        if (*(control_points_data + i) > 0){
            *(voi_id + ii) = i;
            ii += 1;
        }
    }

    // ------------------------------------------------------------------------
    // NOTE(Faruk): This part is for speeding up the final Voronoi propagation
    // ------------------------------------------------------------------------
    // Reduce number of looped-through voxels for the second stage (Voronoi)
    uint32_t nr_voi2 = 0;  // Voxels of interest
    for (uint32_t i = 0; i != nr_voxels; ++i) {
        if (*(nii_rim_data + i) == 3){
            nr_voi2 += 1;
        }
    }
    cout << "  Nr. rim (3) voxels = " << nr_voi2 << endl;

    // Allocate memory to only the voxel of interest
    int32_t* voi_id2;
    voi_id2 = (int32_t*) malloc(nr_voi2*sizeof(int32_t));
    // Fill in indices to be able to remap from subset to full set of voxels
    uint32_t iii = 0;
    for (uint32_t i = 0; i != nr_voxels; ++i) {
        if (*(nii_rim_data + i) == 3){
            *(voi_id2 + iii) = i;
            iii += 1;
        }
    }

    // ========================================================================
    // Initial flood from centroid
    // ========================================================================
    cout << "\n  Checking control points..." << endl;
    // Find the initial voxel
    uint32_t control_point0;  // Origin
    uint32_t control_point1 = 0, control_point2 = 0;  // First extrema pair
    uint32_t control_point3 = 0, control_point4 = 0;  // Second extrema pair
    for (uint32_t i = 0; i != nr_voxels; ++i) {
        if (*(control_points_data + i) == 2) {  // Centroid/origin
            control_point0 = i;
        } else if (*(control_points_data + i) == 3) {
            control_point1 = i;
        } else if (*(control_points_data + i) == 4) {
            control_point2 = i;
        } else if (*(control_points_data + i) == 5) {
            control_point3 = i;
        } else if (*(control_points_data + i) == 6) {
            control_point4 = i;
        }
    }

    bool mode_custom_extrema = false, mode_custom_origin = false;
    if (control_point0 != 0 && control_point1 !=0 && control_point2 !=0
        && control_point3 !=0 && control_point4 !=0) {
        cout << "    Case (II): Origin and extrema quartet voxels are found." << endl;
        mode_custom_extrema = true;
        mode_custom_origin = true;
    } else if (control_point1 !=0 && control_point2 !=0
               && control_point3 !=0 && control_point4 !=0) {
        cout << "    Case (III): Only extrema quartet voxels are found." << endl;
        mode_custom_extrema = true;
    } else if (control_point0 != 0) {
        cout << "    Case (I): Only origin voxel is found." << endl;
    } else {
        cout << "    ERROR! Origin and extrema quartet voxels are NOT found!" << endl;
        cout << "    Check your '-control_points' input file." << endl;
        cout << "    Stopping program." << endl;
        return 2;
    }


    int32_t grow_step = 1;
    uint32_t voxel_counter = nr_voxels;
    uint32_t ix, iy, iz, i, j;
    float d;

    if (!mode_custom_extrema) {
        cout << "\n  Computing control point 0 distances..." << endl;
        // Initialize grow volume
        for (uint32_t i = 0; i != nr_voxels; ++i) {
            if (*(control_points_data + i) == 2) {
                *(flood_step_data + i) = 1.;
                *(flood_dist_data + i) = 0.;
            }
        }

        while (voxel_counter != 0) {
            voxel_counter = 0;
            for (uint32_t ii = 0; ii != nr_voi; ++ii) {
                i = *(voi_id + ii);  // Map subset to full set
                if (*(flood_step_data + i) == grow_step) {
                    tie(ix, iy, iz) = ind2sub_3D(i, size_x, size_y);
                    voxel_counter += 1;

                    // --------------------------------------------------------
                    // 1-jump neighbours
                    // --------------------------------------------------------
                    if (ix > 0) {
                        j = sub2ind_3D(ix-1, iy, iz, size_x, size_y);
                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dX;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x) {
                        j = sub2ind_3D(ix+1, iy, iz, size_x, size_y);
                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dX;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy > 0) {
                        j = sub2ind_3D(ix, iy-1, iz, size_x, size_y);
                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dY;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy < end_y) {
                        j = sub2ind_3D(ix, iy+1, iz, size_x, size_y);
                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dY;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iz > 0) {
                        j = sub2ind_3D(ix, iy, iz-1, size_x, size_y);
                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dZ;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iz < end_z) {
                        j = sub2ind_3D(ix, iy, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dZ;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    // --------------------------------------------------------
                    // 2-jump neighbours
                    // --------------------------------------------------------
                    if (ix > 0 && iy > 0) {
                        j = sub2ind_3D(ix-1, iy-1, iz, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xy;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iy < end_y) {
                        j = sub2ind_3D(ix-1, iy+1, iz, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xy;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy > 0) {
                        j = sub2ind_3D(ix+1, iy-1, iz, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xy;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy < end_y) {
                        j = sub2ind_3D(ix+1, iy+1, iz, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xy;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy > 0 && iz > 0) {
                        j = sub2ind_3D(ix, iy-1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_yz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy > 0 && iz < end_z) {
                        j = sub2ind_3D(ix, iy-1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_yz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy < end_y && iz > 0) {
                        j = sub2ind_3D(ix, iy+1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_yz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy < end_y && iz < end_z) {
                        j = sub2ind_3D(ix, iy+1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_yz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iz > 0) {
                        j = sub2ind_3D(ix-1, iy, iz-1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iz > 0) {
                        j = sub2ind_3D(ix+1, iy, iz-1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iz < end_z) {
                        j = sub2ind_3D(ix-1, iy, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iz < end_z) {
                        j = sub2ind_3D(ix+1, iy, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }

                    // --------------------------------------------------------
                    // 3-jump neighbours
                    // --------------------------------------------------------
                    if (ix > 0 && iy > 0 && iz > 0) {
                        j = sub2ind_3D(ix-1, iy-1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iy > 0 && iz < end_z) {
                        j = sub2ind_3D(ix-1, iy-1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iy < end_y && iz > 0) {
                        j = sub2ind_3D(ix-1, iy+1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy > 0 && iz > 0) {
                        j = sub2ind_3D(ix+1, iy-1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iy < end_y && iz < end_z) {
                        j = sub2ind_3D(ix-1, iy+1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy > 0 && iz < end_z) {
                        j = sub2ind_3D(ix+1, iy-1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy < end_y && iz > 0) {
                        j = sub2ind_3D(ix+1, iy+1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy < end_y && iz < end_z) {
                        j = sub2ind_3D(ix+1, iy+1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                }
            }
            grow_step += 1;
        }

        if (mode_debug) {
            save_output_nifti(fout, "centroid_dist", flood_dist, false);
        }


        // ========================================================================
        // Find perimeter
        // ========================================================================
        cout << "\n  Finding perimeter..." << endl;

        // Translate 0 crossing
        for (uint32_t ii = 0; ii != nr_voi; ++ii) {
            i = *(voi_id + ii);
            if (*(flood_dist_data + i) != 0) {
                *(flood_dist_data + i) -= thr_radius;
            } else {  // These voxels are disconnected to centroid cluster
                *(flood_dist_data + i) = 666;
            }
        }

        // Mark voxels inside perimeter
        for (uint32_t ii = 0; ii != nr_voi; ++ii) {
            i = *(voi_id + ii);
            if (*(flood_dist_data + i) < 0) {
                *(perimeter_data + i) = 1;
            }
        }

        // NOTE(Faruk): Once the proof of concept is working, I need to reduce code
        // repetition here through functions. Signbit checks are easy reductions.
        for (uint32_t ii = 0; ii != nr_voi; ++ii) {
            i = *(voi_id + ii);  // Map subset to full set
            // Check sign changes to find zero crossings
            if (*(flood_dist_data + i) == 0) {
                *(perimeter_data + i) = 2;
            } else {
                float m = *(flood_dist_data + i);
                float n;
                tie(ix, iy, iz) = ind2sub_3D(i, size_x, size_y);

                // --------------------------------------------------------
                // 1-jump neighbours
                // --------------------------------------------------------
                if (ix > 0) {
                    j = sub2ind_3D(ix-1, iy, iz, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (ix < end_x) {
                    j = sub2ind_3D(ix-1, iy, iz, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (iy > 0) {
                    j = sub2ind_3D(ix-1, iy, iz, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (iy < end_y) {
                    j = sub2ind_3D(ix-1, iy, iz, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (iz > 0) {
                    j = sub2ind_3D(ix-1, iy, iz, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (iz < end_z) {
                    j = sub2ind_3D(ix-1, iy, iz, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                // --------------------------------------------------------
                // 2-jump neighbours
                // --------------------------------------------------------
                if (ix > 0 && iy > 0) {
                    j = sub2ind_3D(ix-1, iy-1, iz, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (ix > 0 && iy < end_y) {
                    j = sub2ind_3D(ix-1, iy+1, iz, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (ix < end_x && iy > 0) {
                    j = sub2ind_3D(ix+1, iy-1, iz, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (ix < end_x && iy < end_y) {
                    j = sub2ind_3D(ix+1, iy+1, iz, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (iy > 0 && iz > 0) {
                    j = sub2ind_3D(ix, iy-1, iz-1, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (iy > 0 && iz < end_z) {
                    j = sub2ind_3D(ix, iy-1, iz+1, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (iy < end_y && iz > 0) {
                    j = sub2ind_3D(ix, iy+1, iz-1, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (iy < end_y && iz < end_z) {
                    j = sub2ind_3D(ix, iy+1, iz+1, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (ix > 0 && iz > 0) {
                    j = sub2ind_3D(ix-1, iy, iz-1, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (ix < end_x && iz > 0) {
                    j = sub2ind_3D(ix+1, iy, iz-1, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (ix > 0 && iz < end_z) {
                    j = sub2ind_3D(ix-1, iy, iz+1, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (ix < end_x && iz < end_z) {
                    j = sub2ind_3D(ix+1, iy, iz+1, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                // --------------------------------------------------------
                // 3-jump neighbours
                // --------------------------------------------------------
                if (ix > 0 && iy > 0 && iz > 0) {
                    j = sub2ind_3D(ix-1, iy-1, iz-1, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (ix > 0 && iy > 0 && iz < end_z) {
                    j = sub2ind_3D(ix-1, iy-1, iz+1, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (ix > 0 && iy < end_y && iz > 0) {
                    j = sub2ind_3D(ix-1, iy+1, iz-1, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (ix < end_x && iy > 0 && iz > 0) {
                    j = sub2ind_3D(ix+1, iy-1, iz-1, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (ix > 0 && iy < end_y && iz < end_z) {
                    j = sub2ind_3D(ix-1, iy+1, iz+1, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (ix < end_x && iy > 0 && iz < end_z) {
                    j = sub2ind_3D(ix+1, iy-1, iz+1, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (ix < end_x && iy < end_y && iz > 0) {
                    j = sub2ind_3D(ix+1, iy+1, iz-1, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
                if (ix < end_x && iy < end_y && iz < end_z) {
                    j = sub2ind_3D(ix+1, iy+1, iz+1, size_x, size_y);
                    if (*(control_points_data + j) > 0){
                        n = *(flood_dist_data + j);
                        if (signbit(m) - signbit(n) != 0) {
                            if (m*m < n*n) {
                                *(perimeter_data + i) = 2;
                            } else if (m*m > n*n) {  // Closer to prev. step
                                *(perimeter_data + j) = 2;
                            } else {  // Equal +/- normalized distance
                                *(perimeter_data + i) = 2;
                                *(perimeter_data + j) = 2;
                            }
                        }
                    }
                }
            }
        }
        save_output_nifti(fout, "perimeter", perimeter, false);

        // ====================================================================
        // Find control point extrema and compute distances on midgm domain
        // ====================================================================
        cout << "\n  Computing control points 1 to 4..." << endl;
        if (mode_custom_extrema) {
            cout << "    Using custom extrema control points." << endl;
        } else {
            cout << "    Finding extrema control points on perimeter.\n" << endl;
            // Find first point on perimeter
            for (uint32_t ii = 0; ii != nr_voi; ++ii) {
                i = *(voi_id + ii);  // Map subset to full set
                if (*(perimeter_data + i) == 2) {
                    control_point1 = i;
                }
            }
            *(control_points_data + control_point1) = 3;

            // Loop until desired number of points reached
            for (int32_t n = 4; n < 7; ++n) {
                int32_t grow_step = 1;
                uint32_t voxel_counter = nr_voxels;
                uint32_t ix, iy, iz, i, j;
                float d;

                // Initialize grow volume
                for (uint32_t i = 0; i != nr_voxels; ++i) {
                    if (*(control_points_data + i) > 1) {
                        *(flood_step_data + i) = 1.;
                        *(flood_dist_data + i) = 0.;
                    } else {
                        *(flood_step_data + i) = 0.;
                        *(flood_dist_data + i) = 0.;
                    }
                }

                // Reset some parameters
                grow_step = 1;
                voxel_counter = nr_voxels;
                while (voxel_counter != 0) {
                    voxel_counter = 0;
                    for (uint32_t ii = 0; ii != nr_voi; ++ii) {
                        i = *(voi_id + ii);  // Map subset to full set
                        if (*(flood_step_data + i) == grow_step) {
                            tie(ix, iy, iz) = ind2sub_3D(i, size_x, size_y);
                            voxel_counter += 1;

                            // ------------------------------------------------
                            // 1-jump neighbours
                            // ------------------------------------------------
                            if (ix > 0) {
                                j = sub2ind_3D(ix-1, iy, iz, size_x, size_y);
                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dX;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (ix < end_x) {
                                j = sub2ind_3D(ix+1, iy, iz, size_x, size_y);
                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dX;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (iy > 0) {
                                j = sub2ind_3D(ix, iy-1, iz, size_x, size_y);
                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dY;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (iy < end_y) {
                                j = sub2ind_3D(ix, iy+1, iz, size_x, size_y);
                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dY;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (iz > 0) {
                                j = sub2ind_3D(ix, iy, iz-1, size_x, size_y);
                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dZ;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (iz < end_z) {
                                j = sub2ind_3D(ix, iy, iz+1, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dZ;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            // ------------------------------------------------
                            // 2-jump neighbours
                            // ------------------------------------------------
                            if (ix > 0 && iy > 0) {
                                j = sub2ind_3D(ix-1, iy-1, iz, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_xy;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (ix > 0 && iy < end_y) {
                                j = sub2ind_3D(ix-1, iy+1, iz, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_xy;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (ix < end_x && iy > 0) {
                                j = sub2ind_3D(ix+1, iy-1, iz, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_xy;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (ix < end_x && iy < end_y) {
                                j = sub2ind_3D(ix+1, iy+1, iz, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_xy;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (iy > 0 && iz > 0) {
                                j = sub2ind_3D(ix, iy-1, iz-1, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_yz;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (iy > 0 && iz < end_z) {
                                j = sub2ind_3D(ix, iy-1, iz+1, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_yz;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (iy < end_y && iz > 0) {
                                j = sub2ind_3D(ix, iy+1, iz-1, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_yz;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (iy < end_y && iz < end_z) {
                                j = sub2ind_3D(ix, iy+1, iz+1, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_yz;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (ix > 0 && iz > 0) {
                                j = sub2ind_3D(ix-1, iy, iz-1, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_xz;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (ix < end_x && iz > 0) {
                                j = sub2ind_3D(ix+1, iy, iz-1, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_xz;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (ix > 0 && iz < end_z) {
                                j = sub2ind_3D(ix-1, iy, iz+1, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_xz;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (ix < end_x && iz < end_z) {
                                j = sub2ind_3D(ix+1, iy, iz+1, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_xz;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }

                            // ------------------------------------------------
                            // 3-jump neighbours
                            // ------------------------------------------------
                            if (ix > 0 && iy > 0 && iz > 0) {
                                j = sub2ind_3D(ix-1, iy-1, iz-1, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_xyz;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (ix > 0 && iy > 0 && iz < end_z) {
                                j = sub2ind_3D(ix-1, iy-1, iz+1, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_xyz;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (ix > 0 && iy < end_y && iz > 0) {
                                j = sub2ind_3D(ix-1, iy+1, iz-1, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_xyz;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (ix < end_x && iy > 0 && iz > 0) {
                                j = sub2ind_3D(ix+1, iy-1, iz-1, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_xyz;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (ix > 0 && iy < end_y && iz < end_z) {
                                j = sub2ind_3D(ix-1, iy+1, iz+1, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_xyz;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (ix < end_x && iy > 0 && iz < end_z) {
                                j = sub2ind_3D(ix+1, iy-1, iz+1, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_xyz;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (ix < end_x && iy < end_y && iz > 0) {
                                j = sub2ind_3D(ix+1, iy+1, iz-1, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_xyz;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                            if (ix < end_x && iy < end_y && iz < end_z) {
                                j = sub2ind_3D(ix+1, iy+1, iz+1, size_x, size_y);

                                if (*(perimeter_data + j) == 2) {
                                    d = *(flood_dist_data + i) + dia_xyz;
                                    if (d < *(flood_dist_data + j)
                                        || *(flood_dist_data + j) == 0) {
                                        *(flood_dist_data + j) = d;
                                        *(flood_step_data + j) = grow_step + 1;
                                    }
                                }
                            }
                        }
                    }
                    grow_step += 1;
                }

                // Find farthest point
                float max_distance = 0;
                int idx_new_point;
                for (uint32_t ii = 0; ii != nr_voi; ++ii) {
                    i = *(voi_id + ii);
                    if (*(perimeter_data + i) == 2) {
                        if (*(flood_dist_data + i) > max_distance) {
                            max_distance = *(flood_dist_data + i);
                            idx_new_point = i;
                        }
                    }
                }
                *(control_points_data + idx_new_point) = n;
            }
            if (mode_debug) {
                save_output_nifti(fout, "auto_control_points", control_points, false);
            }
        }
    }

    // ========================================================================
    // Compute flood distances from each extrema control points
    // ========================================================================
    cout << "  Computing control point (1 to 4) distances..." << endl;
    for (int p = 3; p < 7; ++p) {
        cout << "    Relative to control point" + std::to_string(p-2) + "..." << endl;
        // Initialize grow volume
        for (uint32_t i = 0; i != nr_voxels; ++i) {
            if (*(control_points_data + i) == p) {
                *(flood_step_data + i) = 1.;
                *(flood_dist_data + i) = 1.;
            } else {
                *(flood_step_data + i) = 0.;
                *(flood_dist_data + i) = 0.;
            }
        }

        // Reset some parameters
        grow_step = 1;
        voxel_counter = nr_voxels;

        while (voxel_counter != 0) {
            voxel_counter = 0;
            for (uint32_t ii = 0; ii != nr_voi; ++ii) {
                i = *(voi_id + ii);  // Map subset to full set
                if (*(flood_step_data + i) == grow_step) {
                    tie(ix, iy, iz) = ind2sub_3D(i, size_x, size_y);
                    voxel_counter += 1;

                    // --------------------------------------------------------
                    // 1-jump neighbours
                    // --------------------------------------------------------
                    if (ix > 0) {
                        j = sub2ind_3D(ix-1, iy, iz, size_x, size_y);
                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dX;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x) {
                        j = sub2ind_3D(ix+1, iy, iz, size_x, size_y);
                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dX;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy > 0) {
                        j = sub2ind_3D(ix, iy-1, iz, size_x, size_y);
                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dY;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy < end_y) {
                        j = sub2ind_3D(ix, iy+1, iz, size_x, size_y);
                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dY;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iz > 0) {
                        j = sub2ind_3D(ix, iy, iz-1, size_x, size_y);
                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dZ;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iz < end_z) {
                        j = sub2ind_3D(ix, iy, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dZ;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    // --------------------------------------------------------
                    // 2-jump neighbours
                    // --------------------------------------------------------
                    if (ix > 0 && iy > 0) {
                        j = sub2ind_3D(ix-1, iy-1, iz, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xy;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iy < end_y) {
                        j = sub2ind_3D(ix-1, iy+1, iz, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xy;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy > 0) {
                        j = sub2ind_3D(ix+1, iy-1, iz, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xy;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy < end_y) {
                        j = sub2ind_3D(ix+1, iy+1, iz, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xy;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy > 0 && iz > 0) {
                        j = sub2ind_3D(ix, iy-1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_yz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy > 0 && iz < end_z) {
                        j = sub2ind_3D(ix, iy-1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_yz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy < end_y && iz > 0) {
                        j = sub2ind_3D(ix, iy+1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_yz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy < end_y && iz < end_z) {
                        j = sub2ind_3D(ix, iy+1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_yz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iz > 0) {
                        j = sub2ind_3D(ix-1, iy, iz-1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iz > 0) {
                        j = sub2ind_3D(ix+1, iy, iz-1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iz < end_z) {
                        j = sub2ind_3D(ix-1, iy, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iz < end_z) {
                        j = sub2ind_3D(ix+1, iy, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }

                    // --------------------------------------------------------
                    // 3-jump neighbours
                    // --------------------------------------------------------
                    if (ix > 0 && iy > 0 && iz > 0) {
                        j = sub2ind_3D(ix-1, iy-1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iy > 0 && iz < end_z) {
                        j = sub2ind_3D(ix-1, iy-1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iy < end_y && iz > 0) {
                        j = sub2ind_3D(ix-1, iy+1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy > 0 && iz > 0) {
                        j = sub2ind_3D(ix+1, iy-1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iy < end_y && iz < end_z) {
                        j = sub2ind_3D(ix-1, iy+1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy > 0 && iz < end_z) {
                        j = sub2ind_3D(ix+1, iy-1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy < end_y && iz > 0) {
                        j = sub2ind_3D(ix+1, iy+1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy < end_y && iz < end_z) {
                        j = sub2ind_3D(ix+1, iy+1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) > 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                }
            }
            grow_step += 1;
        }

        if (mode_debug) {
            save_output_nifti(fout, "control_point" + std::to_string(p-2) + "_dist", flood_dist, false);
        }

        // Record distances into a 4D nifti
        for (uint32_t ii = 0; ii != nr_voi; ++ii) {
            i = *(voi_id + ii);  // Map subset to full set
            *(point_dist_data + nr_voxels*(p-3) + i) = *(flood_dist_data + i);
        }
    }

    // ------------------------------------------------------------------------
    // Derive coordinates from control point (1, 2, 3, 4) distances
    // ------------------------------------------------------------------------
    cout << "\n  Computing control point coordinates..." << endl;
    // Subtract distances pair-wise to get axis coordinates
    for (uint32_t t = 0; t != 2; ++t) {
        for (uint32_t ii = 0; ii != nr_voi; ++ii) {
            i = *(voi_id + ii);
            float dist1 = *(point_dist_data + nr_voxels*(2 * t) + i);
            float dist2 = *(point_dist_data + nr_voxels*(2 * t + 1) + i);
            *(point_coords_data + nr_voxels*t + i) = dist2 - dist1;
        }
    }

    // ------------------------------------------------------------------------
    // Adjust origin
    // ------------------------------------------------------------------------
    if (mode_custom_origin) {
        float origin_U = *(point_coords_data + nr_voxels*0 + control_point0);
        float origin_V = *(point_coords_data + nr_voxels*1 + control_point0);
        for (uint32_t iii = 0; iii != nr_voi2; ++iii) {
            i = *(voi_id2 + iii);
            *(point_coords_data + nr_voxels*0 + i) -= origin_U;
            *(point_coords_data + nr_voxels*1 + i) -= origin_V;
        }
    }

    if (mode_debug) {
        save_output_nifti(fout, "control_point_coordinates", point_coords, true);
    }

    // ========================================================================
    // Find rolling pin axes
    // ========================================================================
    cout << "\n  Finding pin axes..." << endl;
    for (uint32_t i = 0; i != nr_voxels; ++i) {
        *(pin_axes_data + nr_voxels * 0 + i) = 0;
        *(pin_axes_data + nr_voxels * 1 + i) = 0;
    }

    for (uint32_t t = 0; t != 2; ++t) {
        for (uint32_t ii = 0; ii != nr_voi; ++ii) {
            uint32_t i = *(voi_id + ii);
            tie(ix, iy, iz) = ind2sub_3D(i, size_x, size_y);

            // Check sign changes in normalized distance differences between
            // neighbouring voxels
            float m = *(point_coords_data + nr_voxels * t + i);
            float n;

            // ------------------------------------------------------------
            // 1-jump neighbours
            // ------------------------------------------------------------
            if (ix > 0) {
                j = sub2ind_3D(ix-1, iy, iz, size_x, size_y);
                n = *(point_coords_data + nr_voxels * t + j);
                if (*(control_points_data + j) != 0) {
                    if (signbit(m) - signbit(n) != 0) {
                        *(pin_axes_data + nr_voxels * t + i) = 1;
                    }
                }
            }
            if (ix < end_x) {
                j = sub2ind_3D(ix+1, iy, iz, size_x, size_y);
                n = *(point_coords_data + nr_voxels * t + j);
                if (*(control_points_data + j) != 0) {
                    if (signbit(m) - signbit(n) != 0) {
                        *(pin_axes_data + nr_voxels * t + i) = 1;
                    }
                }
            }
            if (iy > 0) {
                j = sub2ind_3D(ix, iy-1, iz, size_x, size_y);
                n = *(point_coords_data + nr_voxels * t + j);
                if (*(control_points_data + j) != 0) {
                    if (signbit(m) - signbit(n) != 0) {
                        *(pin_axes_data + nr_voxels * t + i) = 1;
                    }
                }
            }
            if (iy < end_y) {
                j = sub2ind_3D(ix, iy+1, iz, size_x, size_y);
                n = *(point_coords_data + nr_voxels * t + j);
                if (*(control_points_data + j) != 0) {
                    if (signbit(m) - signbit(n) != 0) {
                        *(pin_axes_data + nr_voxels * t + i) = 1;
                    }
                }
            }
            if (iz > 0) {
                j = sub2ind_3D(ix, iy, iz-1, size_x, size_y);
                n = *(point_coords_data + nr_voxels * t + j);
                if (*(control_points_data + j) != 0) {
                    if (signbit(m) - signbit(n) != 0) {
                        *(pin_axes_data + nr_voxels * t + i) = 1;
                    }
                }
            }
            if (iz < end_z) {
                j = sub2ind_3D(ix, iy, iz+1, size_x, size_y);
                n = *(point_coords_data + nr_voxels * t + j);
                if (*(control_points_data + j) != 0) {
                    if (signbit(m) - signbit(n) != 0) {
                        *(pin_axes_data + nr_voxels * t + i) = 1;
                    }
                }
            }
        }
    }
    if (mode_debug) {
        save_output_nifti(fout, "pin_axes", pin_axes, true);
    }

    // ========================================================================
    // Compute flood distances relative to pin axes
    // ========================================================================
    cout << "\n  Computing pin axis distances..." << endl;
    for (int p = 0; p != 2; ++p) {
        cout << "    Relative to pin axis " + std::to_string(p+1) + "/2..." << endl;

        // TODO(Faruk): Guesstimate an initial distance to axis lines. Probably
        // I can do this better by considering the local neighbourhood in the
        // future.
        float dist_to_axes = ((dX + dY + dZ) / 3) / 2;  // Half a voxel

        // Initialize grow volume
        for (uint32_t i = 0; i != nr_voxels; ++i) {
            if (*(pin_axes_data + nr_voxels * p + i) != 0) {
                *(flood_step_data + i) = 1.;
                *(flood_dist_data + i) = dist_to_axes;
            } else {
                *(flood_step_data + i) = 0.;
                *(flood_dist_data + i) = 0.;
            }
        }

        // Reset some parameters
        grow_step = 1;
        voxel_counter = nr_voxels;

        while (voxel_counter != 0) {
            voxel_counter = 0;
            for (uint32_t ii = 0; ii != nr_voi; ++ii) {
                i = *(voi_id + ii);  // Map subset to full set
                if (*(flood_step_data + i) == grow_step) {
                    tie(ix, iy, iz) = ind2sub_3D(i, size_x, size_y);
                    voxel_counter += 1;

                    // --------------------------------------------------------
                    // 1-jump neighbours
                    // --------------------------------------------------------
                    if (ix > 0) {
                        j = sub2ind_3D(ix-1, iy, iz, size_x, size_y);
                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dX;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x) {
                        j = sub2ind_3D(ix+1, iy, iz, size_x, size_y);
                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dX;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy > 0) {
                        j = sub2ind_3D(ix, iy-1, iz, size_x, size_y);
                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dY;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy < end_y) {
                        j = sub2ind_3D(ix, iy+1, iz, size_x, size_y);
                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dY;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iz > 0) {
                        j = sub2ind_3D(ix, iy, iz-1, size_x, size_y);
                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dZ;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iz < end_z) {
                        j = sub2ind_3D(ix, iy, iz+1, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dZ;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    // --------------------------------------------------------
                    // 2-jump neighbours
                    // --------------------------------------------------------
                    if (ix > 0 && iy > 0) {
                        j = sub2ind_3D(ix-1, iy-1, iz, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_xy;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iy < end_y) {
                        j = sub2ind_3D(ix-1, iy+1, iz, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_xy;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy > 0) {
                        j = sub2ind_3D(ix+1, iy-1, iz, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_xy;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy < end_y) {
                        j = sub2ind_3D(ix+1, iy+1, iz, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_xy;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy > 0 && iz > 0) {
                        j = sub2ind_3D(ix, iy-1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_yz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy > 0 && iz < end_z) {
                        j = sub2ind_3D(ix, iy-1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_yz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy < end_y && iz > 0) {
                        j = sub2ind_3D(ix, iy+1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_yz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (iy < end_y && iz < end_z) {
                        j = sub2ind_3D(ix, iy+1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_yz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iz > 0) {
                        j = sub2ind_3D(ix-1, iy, iz-1, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_xz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iz > 0) {
                        j = sub2ind_3D(ix+1, iy, iz-1, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_xz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iz < end_z) {
                        j = sub2ind_3D(ix-1, iy, iz+1, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_xz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iz < end_z) {
                        j = sub2ind_3D(ix+1, iy, iz+1, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_xz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }

                    // --------------------------------------------------------
                    // 3-jump neighbours
                    // --------------------------------------------------------
                    if (ix > 0 && iy > 0 && iz > 0) {
                        j = sub2ind_3D(ix-1, iy-1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iy > 0 && iz < end_z) {
                        j = sub2ind_3D(ix-1, iy-1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iy < end_y && iz > 0) {
                        j = sub2ind_3D(ix-1, iy+1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy > 0 && iz > 0) {
                        j = sub2ind_3D(ix+1, iy-1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix > 0 && iy < end_y && iz < end_z) {
                        j = sub2ind_3D(ix-1, iy+1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy > 0 && iz < end_z) {
                        j = sub2ind_3D(ix+1, iy-1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy < end_y && iz > 0) {
                        j = sub2ind_3D(ix+1, iy+1, iz-1, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                    if (ix < end_x && iy < end_y && iz < end_z) {
                        j = sub2ind_3D(ix+1, iy+1, iz+1, size_x, size_y);

                        if (*(control_points_data + j) != 0) {
                            d = *(flood_dist_data + i) + dia_xyz;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                            }
                        }
                    }
                }
            }
            grow_step += 1;
        }

        if (mode_debug) {
            save_output_nifti(fout, "pin_axis" + std::to_string(p+1) + "_dist", flood_dist, true);
        }

        // Save distances into 4D nifti
        for (uint32_t ii = 0; ii != nr_voi; ++ii) {
            i = *(voi_id + ii);  // Map subset to full set
            // Transfer signs onto pin distances to convert them to coordinates
            if (*(point_coords_data + nr_voxels * p + i) < 0) {
                *(pin_coords_data + nr_voxels * p + i) = -*(flood_dist_data + i);
            } else {
                *(pin_coords_data + nr_voxels * p + i) = *(flood_dist_data + i);
            }
        }
    }

    if (mode_debug) {
        save_output_nifti(fout, "pin_coordinates", pin_coords, true);
    }

    // ========================================================================
    // Final Voronoi for propagating distances to all gray matter
    // ========================================================================
    cout << "\n  Start Voronoi propagation..." << endl;
    for (uint32_t t = 0; t != 2; ++t) {
        cout << "    Doing coordinate " + std::to_string(t+1) + "/2..." << endl;
        // Initialize grow volume
        for (uint32_t iii = 0; iii != nr_voi2; ++iii) {
            i = *(voi_id2 + iii);  // Map subset to full set
            if (*(pin_coords_data + nr_voxels*t + i) != 0) {
                *(voronoi_data + i) = *(pin_coords_data + nr_voxels*t + i);
                *(flood_step_data + i) = 1.;
                *(flood_dist_data + i) = 1.;
            } else {
                *(voronoi_data + i) = 0;
                *(flood_step_data + i) = 0.;
                *(flood_dist_data + i) = 0.;
            }
        }

        grow_step = 1;
        voxel_counter = nr_voxels;

        while (voxel_counter != 0) {
            voxel_counter = 0;
            for (uint32_t iii = 0; iii != nr_voi2; ++iii) {
                i = *(voi_id2 + iii);
                if (*(flood_step_data + i) == grow_step) {
                    tie(ix, iy, iz) = ind2sub_3D(i, size_x, size_y);
                    voxel_counter += 1;

                    bool jump_lock = false;
                    // --------------------------------------------------------
                    // 1-jump neighbours
                    // --------------------------------------------------------
                    if (ix > 0) {
                        j = sub2ind_3D(ix-1, iy, iz, size_x, size_y);
                        if (*(nii_rim_data + j) == 3) {
                            d = *(flood_dist_data + i) + dX;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                                *(voronoi_data + j) = *(voronoi_data + i);
                            }
                        } else if (*(nii_rim_data + j) != 0) {
                            jump_lock = true;
                        }
                    }
                    if (ix < end_x) {
                        j = sub2ind_3D(ix+1, iy, iz, size_x, size_y);
                        if (*(nii_rim_data + j) == 3) {
                            d = *(flood_dist_data + i) + dX;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                                *(voronoi_data + j) = *(voronoi_data + i);
                            }
                        } else if (*(nii_rim_data + j) != 0) {
                            jump_lock = true;
                        }
                    }
                    if (iy > 0) {
                        j = sub2ind_3D(ix, iy-1, iz, size_x, size_y);
                        if (*(nii_rim_data + j) == 3) {
                            d = *(flood_dist_data + i) + dY;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                                *(voronoi_data + j) = *(voronoi_data + i);
                            }
                        } else if (*(nii_rim_data + j) != 0) {
                            jump_lock = true;
                        }
                    }
                    if (iy < end_y) {
                        j = sub2ind_3D(ix, iy+1, iz, size_x, size_y);
                        if (*(nii_rim_data + j) == 3) {
                            d = *(flood_dist_data + i) + dY;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                                *(voronoi_data + j) = *(voronoi_data + i);
                            }
                        } else if (*(nii_rim_data + j) != 0) {
                            jump_lock = true;
                        }
                    }
                    if (iz > 0) {
                        j = sub2ind_3D(ix, iy, iz-1, size_x, size_y);
                        if (*(nii_rim_data + j) == 3) {
                            d = *(flood_dist_data + i) + dZ;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                                *(voronoi_data + j) = *(voronoi_data + i);
                            }
                        } else if (*(nii_rim_data + j) != 0) {
                            jump_lock = true;
                        }
                    }
                    if (iz < end_z) {
                        j = sub2ind_3D(ix, iy, iz+1, size_x, size_y);

                        if (*(nii_rim_data + j) == 3) {
                            d = *(flood_dist_data + i) + dZ;
                            if (d < *(flood_dist_data + j)
                                || *(flood_dist_data + j) == 0) {
                                *(flood_dist_data + j) = d;
                                *(flood_step_data + j) = grow_step + 1;
                                *(voronoi_data + j) = *(voronoi_data + i);
                            }
                        } else if (*(nii_rim_data + j) != 0) {
                            jump_lock = true;
                        }
                    }

                    // --------------------------------------------------------
                    // 2-jump neighbours
                    // --------------------------------------------------------
                    if (jump_lock == false) {

                        if (ix > 0 && iy > 0) {
                            j = sub2ind_3D(ix-1, iy-1, iz, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_xy;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (ix > 0 && iy < end_y) {
                            j = sub2ind_3D(ix-1, iy+1, iz, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_xy;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (ix < end_x && iy > 0) {
                            j = sub2ind_3D(ix+1, iy-1, iz, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_xy;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (ix < end_x && iy < end_y) {
                            j = sub2ind_3D(ix+1, iy+1, iz, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_xy;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (iy > 0 && iz > 0) {
                            j = sub2ind_3D(ix, iy-1, iz-1, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_yz;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (iy > 0 && iz < end_z) {
                            j = sub2ind_3D(ix, iy-1, iz+1, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_yz;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (iy < end_y && iz > 0) {
                            j = sub2ind_3D(ix, iy+1, iz-1, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_yz;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (iy < end_y && iz < end_z) {
                            j = sub2ind_3D(ix, iy+1, iz+1, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_yz;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (ix > 0 && iz > 0) {
                            j = sub2ind_3D(ix-1, iy, iz-1, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_xz;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (ix < end_x && iz > 0) {
                            j = sub2ind_3D(ix+1, iy, iz-1, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_xz;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (ix > 0 && iz < end_z) {
                            j = sub2ind_3D(ix-1, iy, iz+1, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_xz;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (ix < end_x && iz < end_z) {
                            j = sub2ind_3D(ix+1, iy, iz+1, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_xz;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }

                        // ----------------------------------------------------
                        // 3-jump neighbours
                        // ----------------------------------------------------
                        if (ix > 0 && iy > 0 && iz > 0) {
                            j = sub2ind_3D(ix-1, iy-1, iz-1, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_xyz;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (ix > 0 && iy > 0 && iz < end_z) {
                            j = sub2ind_3D(ix-1, iy-1, iz+1, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_xyz;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (ix > 0 && iy < end_y && iz > 0) {
                            j = sub2ind_3D(ix-1, iy+1, iz-1, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_xyz;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (ix < end_x && iy > 0 && iz > 0) {
                            j = sub2ind_3D(ix+1, iy-1, iz-1, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_xyz;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (ix > 0 && iy < end_y && iz < end_z) {
                            j = sub2ind_3D(ix-1, iy+1, iz+1, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_xyz;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (ix < end_x && iy > 0 && iz < end_z) {
                            j = sub2ind_3D(ix+1, iy-1, iz+1, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_xyz;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (ix < end_x && iy < end_y && iz > 0) {
                            j = sub2ind_3D(ix+1, iy+1, iz-1, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_xyz;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                        if (ix < end_x && iy < end_y && iz < end_z) {
                            j = sub2ind_3D(ix+1, iy+1, iz+1, size_x, size_y);

                            if (*(nii_rim_data + j) == 3) {
                                d = *(flood_dist_data + i) + dia_xyz;
                                if (d < *(flood_dist_data + j)
                                    || *(flood_dist_data + j) == 0) {
                                    *(flood_dist_data + j) = d;
                                    *(flood_step_data + j) = grow_step + 1;
                                    *(voronoi_data + j) = *(voronoi_data + i);
                                }
                            }
                        }
                    }
                }
            }
            grow_step += 1;
        }

        // Record into 4D nifti
        for (uint32_t iii = 0; iii != nr_voi2; ++iii) {
            i = *(voi_id2 + iii);  // Map subset to full set
            *(pin_coords_data + nr_voxels * t + i) = *(voronoi_data + i);
        }
    }

    if (mode_debug) {
        save_output_nifti(fout, "pin_coordinates", pin_coords, true);
    }

    // ========================================================================
    // Smooth coordinates
    // ========================================================================
    cout << "\n  Smoothing coordinates..." << endl;
    for (uint32_t t = 0; t != 2; ++t) {
        cout << "    Doing coordinate " + std::to_string(t+1) + "/2..." << endl;
        for (uint32_t i = 0; i != nr_voxels; ++i) {
            *(smooth_data + i) = 0;
        }

        // Pre-compute weights
        float FWHM_val = 1;  // TODO(Faruk): Might tweak this one
        float w_0 = gaus(0, FWHM_val);
        float w_dX = gaus(dX, FWHM_val);
        float w_dY = gaus(dY, FWHM_val);
        float w_dZ = gaus(dZ, FWHM_val);

        for (uint16_t n = 0; n != 2; ++n) {
            for (uint32_t iii = 0; iii != nr_voi2; ++iii) {
                i = *(voi_id2 + iii);
                tie(ix, iy, iz) = ind2sub_3D(i, size_x, size_y);
                float new_val = 0, total_weight = 0;

                // Start with the voxel itself
                new_val += *(pin_coords_data + nr_voxels * t + i) * w_0;
                total_weight += w_0;

                // ------------------------------------------------------------
                // 1-jump neighbours
                // ------------------------------------------------------------
                if (ix > 0) {
                    j = sub2ind_3D(ix-1, iy, iz, size_x, size_y);
                    if (*(nii_rim_data + j) == 3) {
                        new_val += *(pin_coords_data + nr_voxels*t + j) * w_dX;
                        total_weight += w_dX;
                    }
                }
                if (ix < end_x) {
                    j = sub2ind_3D(ix+1, iy, iz, size_x, size_y);
                    if (*(nii_rim_data + j) == 3) {
                        new_val += *(pin_coords_data + nr_voxels*t + j) * w_dX;
                        total_weight += w_dX;
                    }
                }
                if (iy > 0) {
                    j = sub2ind_3D(ix, iy-1, iz, size_x, size_y);
                    if (*(nii_rim_data + j) == 3) {
                        new_val += *(pin_coords_data + nr_voxels*t + j) * w_dY;
                        total_weight += w_dY;
                    }
                }
                if (iy < end_y) {
                    j = sub2ind_3D(ix, iy+1, iz, size_x, size_y);
                    if (*(nii_rim_data + j) == 3) {
                        new_val += *(pin_coords_data + nr_voxels*t + j) * w_dY;
                        total_weight += w_dY;
                    }
                }
                if (iz > 0) {
                    j = sub2ind_3D(ix, iy, iz-1, size_x, size_y);
                    if (*(nii_rim_data + j) == 3) {
                        new_val += *(pin_coords_data + nr_voxels*t + j) * w_dZ;
                        total_weight += w_dZ;
                    }
                }
                if (iz < end_z) {
                    j = sub2ind_3D(ix, iy, iz+1, size_x, size_y);
                    if (*(nii_rim_data + j) == 3) {
                        new_val += *(pin_coords_data + nr_voxels*t + j) * w_dZ;
                        total_weight += w_dZ;
                    }
                }
                *(smooth_data + i) = new_val / total_weight;
            }

            // Swap image that needs to be smoothed
            for (uint32_t iii = 0; iii != nr_voi2; ++iii) {
                i = *(voi_id2 + iii);
                *(pin_coords_data + nr_voxels * t + i) = *(smooth_data + i);
            }
        }
    }

    if (mode_debug) {
        save_output_nifti(fout, "pin_coordinates_smooth", pin_coords, true);
    }

    // ========================================================================
    // Compute norms
    // ========================================================================
    cout << "\n  Computing L2 and Linf norms..." << endl;
    // Compute Linfinity norm
    for (uint32_t iii = 0; iii != nr_voi2; ++iii) {
        i = *(voi_id2 + iii);
        float coord_U = *(pin_coords_data + nr_voxels*0 + i);
        float coord_V = *(pin_coords_data + nr_voxels*1 + i);
        float norm = std::max(std::abs(coord_U), std::abs(coord_V));
        *(flood_dist_data + i) = norm;
    }
    if (mode_norms || mode_debug) {
        save_output_nifti(fout, "UV_norm_Linf", flood_dist, true);
    }

    // Compute L2 norm
    for (uint32_t iii = 0; iii != nr_voi2; ++iii) {
        i = *(voi_id2 + iii);
        float coord_U = *(pin_coords_data + nr_voxels*0 + i);
        float coord_V = *(pin_coords_data + nr_voxels*1 + i);
        float norm = sqrt(coord_U * coord_U + coord_V * coord_V);
        *(flood_dist_data + i) = norm;
    }
    if (mode_norms || mode_debug) {
        save_output_nifti(fout, "UV_norm_L2", flood_dist, true);
    }

    // ========================================================================
    // Update perimeter mask using norm
    // ========================================================================
    cout << "\n  Updating perimeter using L2 norm..." << endl;
    for (uint32_t i = 0; i != nr_voxels; ++i) {
        if (*(flood_dist_data + i) != 0) {
            if (*(flood_dist_data + i) < thr_radius) {
                *(perimeter_data + i) = 1;
            } else {
                *(perimeter_data + i) = 0;
            }
        } else {
            *(perimeter_data + i) = 0;
        }
    }

    // Label perimeter borders
    float thr_radius_with_borders = dia_xyz*2 + thr_radius;
    bool switch_border = false;
    // for (uint32_t i = 0; i != nr_voxels; ++i) {
    for (uint32_t iii = 0; iii != nr_voi2; ++iii) {
        i = *(voi_id2 + iii);
        tie(ix, iy, iz) = ind2sub_3D(i, size_x, size_y);

        if (*(perimeter_data + i) == 0) {
            // --------------------------------------------------------
            // 1-jump neighbours
            // --------------------------------------------------------
            if (ix > 0) {
                j = sub2ind_3D(ix-1, iy, iz, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (ix < end_x) {
                j = sub2ind_3D(ix+1, iy, iz, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (iy > 0) {
                j = sub2ind_3D(ix, iy-1, iz, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (iy < end_y) {
                j = sub2ind_3D(ix, iy+1, iz, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (iz > 0) {
                j = sub2ind_3D(ix, iy, iz-1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (iz < end_z) {
                j = sub2ind_3D(ix, iy, iz+1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            // --------------------------------------------------------
            // 2-jump neighbours
            // --------------------------------------------------------
            if (ix > 0 && iy > 0) {
                j = sub2ind_3D(ix-1, iy-1, iz, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (ix > 0 && iy < end_y) {
                j = sub2ind_3D(ix-1, iy+1, iz, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (ix < end_x && iy > 0) {
                j = sub2ind_3D(ix+1, iy-1, iz, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (ix < end_x && iy < end_y) {
                j = sub2ind_3D(ix+1, iy+1, iz, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (iy > 0 && iz > 0) {
                j = sub2ind_3D(ix, iy-1, iz-1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (iy > 0 && iz < end_z) {
                j = sub2ind_3D(ix, iy-1, iz+1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (iy < end_y && iz > 0) {
                j = sub2ind_3D(ix, iy+1, iz-1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (iy < end_y && iz < end_z) {
                j = sub2ind_3D(ix, iy+1, iz+1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (ix > 0 && iz > 0) {
                j = sub2ind_3D(ix-1, iy, iz-1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (ix < end_x && iz > 0) {
                j = sub2ind_3D(ix+1, iy, iz-1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (ix > 0 && iz < end_z) {
                j = sub2ind_3D(ix-1, iy, iz+1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (ix < end_x && iz < end_z) {
                j = sub2ind_3D(ix+1, iy, iz+1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            // --------------------------------------------------------
            // 3-jump neighbours
            // --------------------------------------------------------
            if (ix > 0 && iy > 0 && iz > 0) {
                j = sub2ind_3D(ix-1, iy-1, iz-1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (ix > 0 && iy > 0 && iz < end_z) {
                j = sub2ind_3D(ix-1, iy-1, iz+1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (ix > 0 && iy < end_y && iz > 0) {
                j = sub2ind_3D(ix-1, iy+1, iz-1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (ix < end_x && iy > 0 && iz > 0) {
                j = sub2ind_3D(ix+1, iy-1, iz-1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (ix > 0 && iy < end_y && iz < end_z) {
                j = sub2ind_3D(ix-1, iy+1, iz+1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (ix < end_x && iy > 0 && iz < end_z) {
                j = sub2ind_3D(ix+1, iy-1, iz+1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (ix < end_x && iy < end_y && iz > 0) {
                j = sub2ind_3D(ix+1, iy+1, iz-1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
            if (ix < end_x && iy < end_y && iz < end_z) {
                j = sub2ind_3D(ix+1, iy+1, iz+1, size_x, size_y);
                if (*(perimeter_data + j) != *(perimeter_data + i)) {
                    switch_border = true;
                }
            }
        }
        // Assign new value
        if (switch_border && *(nii_rim_data + i) == 3
            && *(flood_dist_data + i) < thr_radius_with_borders) {
            *(flood_step_data + i) = 2;
        } else {
            *(flood_step_data + i) = *(perimeter_data + i);
        }
        // Reset switch
        switch_border = false;
    }
    // Update perimeter voxels
    // for (uint32_t i = 0; i != nr_voxels; ++i) {
    for (uint32_t iii = 0; iii != nr_voi2; ++iii) {
        i = *(voi_id2 + iii);
        *(perimeter_data + i) = *(flood_step_data + i);
    }
    save_output_nifti(fout, "perimeter_chunk", perimeter, true);

    // ========================================================================
    // Convert pin axes from 4D nifti into 3D
    // ========================================================================
    cout << "\n  Start preparing axes output (used for quality control)..." << endl;
    for (uint32_t iii = 0; iii != nr_voi2; ++iii) {
        i = *(voi_id2 + iii);

        if (*(pin_axes_data + nr_voxels*0 + i) != 0
            && *(pin_axes_data + nr_voxels*1 + i) != 0) {  // Origin
            *(perimeter_data + i) = 3;
        } else if (*(pin_axes_data + nr_voxels*0 + i) != 0) {  // U axis
            *(perimeter_data + i) = 4;
        } else if (*(pin_axes_data + nr_voxels*1 + i) != 0) {  // V axis
            *(perimeter_data + i) = 5;
        }

        // Mask out voxels that are not middle gray matter
        if (*(control_points_data + i) == 0) {
            *(perimeter_data + i) = 0;
        }
    }

    // ========================================================================
    // Mask out coordinates beyond periphery radius
    // ========================================================================
    if (mode_mask) {
        cout << "\n  Masking outputs..." << endl;
        for (uint32_t iii = 0; iii != nr_voi2; ++iii) {
            i = *(voi_id2 + iii);
            // Zero values outside of perimeter chunk
            if (*(flood_step_data + i) == 0) {
                *(pin_coords_data + nr_voxels*0 + i) = 0;
                *(pin_coords_data + nr_voxels*1 + i) = 0;
                *(perimeter_data + i) = 0;
            }
        }
    }

    save_output_nifti(fout, "UV_axes", perimeter, true);
    save_output_nifti(fout, "UV_coordinates", pin_coords, true);

    // ========================================================================
    // Compute angles & quadrants
    // ========================================================================
    if (mode_angles) {
        cout << "\n  Computing angles (in radians) and quadrants..." << endl;
        for (uint32_t iii = 0; iii != nr_voi2; ++iii) {
            i = *(voi_id2 + iii);
            // Only compute for within the masked region
            if (*(pin_coords_data + i) != 0) {
                float coord1 = *(pin_coords_data + nr_voxels*0 + i);
                float coord2 = *(pin_coords_data + nr_voxels*1 + i);
                // Angles in radians (0 to 2*pi)
                float angle = atan2(coord1, coord2) + PI;
                *(flood_dist_data + i) = angle;  // Repurposing nifti object
                // Derive quadrants from angles
                angle *= 2 / PI;
                float quadrant = floor(angle + 1);
                *(flood_step_data + i) = static_cast<int32_t>(quadrant);
            } else {
                *(flood_dist_data + i) = 0;
                *(flood_step_data + i) = 0;
            }
        }
        save_output_nifti(fout, "UV_radians", flood_dist, true);
        save_output_nifti(fout, "UV_quadrants", flood_step, true);
    }

    cout << "\n  Finished." << endl;
    return 0;
}
